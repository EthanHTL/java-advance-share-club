# 自定义bean的本质
## overview
- 生命周期钩子
- ApplicationContextAware 和 BeanNameAware
- 其他Aware接口

## 1.6.1 生命周期钩子
- 可以基于JSR-250的注解
  - @PostConstruct
  - @PreDestroy
  好吃是不与Spring的接口耦合 ..
- 使用Spring提供的接口
  - DisposableBean 
    - afterPropertiesSet()
  - InitializingBean 
    - destroy()
上述都是实例化和摧毁回调钩子 ...
使用Spring提供的接口提供的方法,最终都是通过BeanPostProcessor进行处理的(在Bean的构造过程中合适的时机进行钩子回调) ...
- Lifecycle 接口
  - 让对象能够参与到启动和停止的过程中,通过容器自己的生命周期驱动 ..

### 通用初始化 / 摧毁 回调检测
默认spring可以检测java.lang.AutoCloseable or java.io.Closeable的公共 close / shutdown方法 ..这是一种约定 ...
当然你可以配置bean元数据(例如指定初始化方法为init,摧毁方法为 cleanUp) ...
```text
public class ExampleBean {

    public void cleanup() {
        // do some destruction work (like releasing pooled connections)
    }
}
```
```xml
<bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/>
```
你甚至还可以修改整体单例bean的 摧毁 / 初始化方法指定
通过<beans>元素的属性配置即可 .. default-destroy-method / default-init-method ..
当然只要检测到了这些方法,spring 会执行任意其中之一 ....

### 在不使用spring提供的接口时,使用默认公共约定的初始化/ 摧毁方法
- init
- initialize
- dispose
- destroy
- close

对于相同目的的生命周期函数仅仅只有一个会执行,取决于扫描顺序
#### init
1. @PostConstruct
2. afterPropertiesSet() as defined by the InitializingBean callback interface
3. A custom configured init() method
#### destroy
1. @PreDestroy
2. destroy() as defined by the DisposableBean callback interface
3. A custom configured destroy() method
### 合并生命周期机制
1. Startup 以及 Shutdown Callbacks
LifeCycle定义了一些对于任何对象(对自己的生命周期有需求的)给出了一些方法(例如开始或者停止后台程序) \
任何Spring管理的对象如果实现了LifeCycle接口,那么当ApplicationContext自己接收到开始或者结束的信号(例如stop / restart场景),它会级联的告诉所有LifeCycle的实现(定义在此上下文中的) ..
它将代理到LifeCycleProcessor 处理器回调这些Lifecycle接口方法 ...
```class
public interface LifecycleProcessor extends Lifecycle {

    void onRefresh();

    void onClose();
}
```
注意LifecycleProcessor实现了LifeCycle并增加了额外的方法和上下文刷新 / 关闭进行交互 .. \
普通的org.springframework.context.Lifecycle仅仅针对显式的启动/ 停止通知不包含隐含上下文刷新时刻的自动启动 ..
为了完全控制指定bean的自动启动(包括启动阶段),使用SmartLifecycle 代替 ..
同样注意到stop通知并不保证出现在解构之前,在定期关闭时,所有的Lifecycle bean首先会接收stop通知(在通常的解构回调传播之前),然而
在上下文的生命周期内进行的热刷新或者停止刷新尝试上,仅仅只有destroy方法将被调用 ...

### startup / shutdown invocations顺序非常重要
如果depends-on关系存在于两个任意的对象上,那么依赖方(在它的依赖之后启动),并且在它的依赖之前停止 ...然而,有些时候直接依赖是未知的,
你也许仅仅知道某些类型的对象启动在其他类型之前,在这种情况下,SmartLifecycle接口定义了其他选项,也就是说 getPhase()方法定义在它的超类接口中 ,Phased ...
```java
public interface Phased {

  int getPhase();
}
```
SmartLifecycle 接口
```java
public interface SmartLifecycle extends Lifecycle, Phased {

    boolean isAutoStartup();

    void stop(Runnable callback);
}
```
当启动的时候,低阶段的对象优先启动,关闭的时候顺序相反 ...因此一个对象如果实现了SmartLifecycle并且getPhase()方法返回Integer.MIN_VALUE 会导致最先启动,最后停止 ..
在范围的另一方,Integer.MAX_VALUE将指示对象最后启动最先停止(就像是因为它依赖于其他需要被运行的过程),当考虑这个阶段值的时候,最重要的是默认阶段(normal),这种阶段的对象不会实现SmartLifeCycle
= 0(中间值),因此任何负数表示对象应该在这些标准组件之前启动,在这些标准组件之后关闭,对于正数反过来也是一样的 .. \
由SmartLifecycle定义的stop方法接收一个回调,当实现的shutdown过程完成之后必须调用callback的run方法 ... 于是异步关闭是必要的 ,由于默认实现是
LifecycleProcessor接口,DefaultLifecycleProcessor,它针对一组对象等待一定的超时时间(在每一个阶段)去执行回调,默认每个阶段的超时时间为 30秒,你可以通过定义一个lifecycleProcessor到上下文中去
覆盖这个默认的行为 ... 
```xml
<bean id="lifecycleProcessor" class="org.springframework.context.support.DefaultLifecycleProcessor">
    <!-- timeout value in milliseconds -->
    <property name="timeoutPerShutdownPhase" value="10000"/>
</bean>
```
LifecycleProcessor 接口定义了回调方法用于关注刷新和上下文的关闭 ...
后者驱动关闭过程(就好像stop被显式的调用),但是发生在上下文被关闭的时候 ... \
刷新回调,是SmartLifecycle bean的另一个特性,当上下文刷新的时候(所有对象已经被实例化并初始化),回调将被执行 ...
此时默认的生命周期处理器会检查SmartLifecycle对象的isAutoStartup()方法,如果返回true,那么将此对象将在此时启动(而不是等待上下文的显式调用或者自己的start方法调用(不像上下文刷新,上下文启动在标准的上下文实现中不会自动发生)),phase值以及任何依赖关系决定了bean的启动顺序 ...

