# 依赖
## 1.4.5 自动装配合作者
spring 容器能够自动装配合作者bean之间的关系,你能够让Spring 解析合作者(其他bean) - 通过检测ApplicationContext中的内容
### 自动装配的优势
- 能够极大的减少指定的属性或者构造器参数(其他机制,例如 bean 模板在这方面也是有用的)
- 自动装配能够随着你的对象的演变更新一个配置,例如 如果你需要为类增加一个依赖,那么依赖能够自动的满足而无需修改配置,所以自动装配在开发阶段非常有用,而不会在代码库变得更稳定时否定切换到显式装配的选项
- 当使用基于xml的配置元数据的时候,你能够指定一个bean的自动装配模式(通过设置 bean元素的 autowire属性即可),自动装配功能有4种模式 ..
  - no 不自动装配,Bean 引用必须通过ref 进行定义,对于大量的部署情况改变默认配置是不建议的,因为明确指定合作者可以提供更大的控制力和清晰度.在某种程度上,它记录了系统的结构.
  - byName 根据属性名自动装配,spring 会查询一个与属性名同名的bean(进行自动装配),例如如果bean 定义设置为通过byName 自动装配并且某个对象它包含了一个master属性,也就是具有setMaster(...)方法,Spring 会查询名称为master的bean 定义并用它设置这个属性 ..
  - byType 如果仅有一个属性类型的bean存在于容器中,自动装配属性 ... 如果发生异常,表示不能使用byType自动装配一个bean(如果没有匹配的bean,什么也不会发生,也就是属性不会被设置) ...
  - constructor 类似于byType,但是它是将bean应用到构造器参数上,如果在容器中没有对应的bean 对应构造器参数,则抛出致命异常 ..
- 使用byType或者 constructor 自动装配模式,你能够装配数组或者具有类型的集合,这种情况下,在这个容器中的所有自动装配候选(匹配对应类型的)将会被提供用来满足这个依赖 ...
    你能够自动装配一个强类型Map实例(如果期待的Key类型是String),自动装配Map实例的值(由匹配期待类型的所有bean实例组成),并且Map实例的key包含了对应的bean 名称 ..
### 缺点
自动装配在项目中一致使用时效果最佳。如果一般不使用自动装配，开发人员可能会混淆使用它来只装配一个或两个 bean 定义。
#### 限制和缺陷
- 在property和constructor-arg设置中的显式依赖总是会覆盖自动装配,你不能够自动装配一个简单属性(例如基本数据类型,String 以及 Class,或者基本数据类型的数组),这是设计所限制的 ..
- 自动装配不如显式装配精确,Spring 会小心的避免歧义所产生未知结果,Spring 管理的对象之间的关系不再明确记录 ..
- 在容器中的多个bean定义都可能匹配由setter方法指定的类型或者由构造器参数匹配的类型能够被自动装配,对于数组,集合,Map实例,这并不是一个问题,但是如果依赖是一个值,那么这种歧义性不能够随便解析, 如果没有独一无二的bean 可用,会抛出异常 ...
    在这种情况下,你能够有几种选择:
  - 显式装配而不是自动装配 ..
  - 通过设置autowire-candidate属性为false,避免自动装配 bean 定义 ...
  - 通过将bean 设置为primary(作为主要候选),通过设置primary 属性为true ..
  - 使用基于注解的容器配置进行更加细腻化的配置 ...
### 将一个Bean从自动装配中排除
  在一个bean的基础上,你能够排除一个bean(进行自动装配),在Spring xml格式下,设置 bean的autowire-candidate属性为false即可 ...
  这会导致特定的bean 定义不能用于自动装配基础设施(包括注解风格的配置,例如@Autowired)
  - autowire-candidate属性仅仅设计来影响基于类型的自动装配,它不会影响显式的by name 引用,即使一个特定的bean 标记为从自动装配中排除 ..
    因此通过名称自动装配会正常工作 ..
  - 你能够限制自动装配候选(针对bean的名称基于模式匹配),xml 风格下beans元素接收一个或者多个 模式,通过default-autowire-candidates属性进行设置 ..
    例如你能够限制自动装配候选状态为 bean的名称以Repository结尾 -> *Repository ... 提供多个模式,通过逗号分隔列表定义即可 ...
    除此之外,bean的autowire-candidate属性具有更高的优先级,对于这样的bean,模式匹配规则不会生效 ...
    这些技术都是有用的(当你不想通过自动装配将bean注入到其他bean中),这并不意味着一个排除的bean不能够通过自动装配配置它自己,相反仅仅只是说它对于自动装配其他bean来说,它不作为候选者而已 ...