# 外观模式

本质上,对于我来说,它跟抽象工厂模式,单例模式,代理,装饰器,适配器模式特别像 ..

为什么呢? 因为抽象工厂模式仅仅限制创建对象的方式,而单例模式限制的是所需对象的数量,代理模式控制对象的行为(在不修改接口功能的前提下,新增能力),

装饰器模式是类似的,(有时候我根本无法认清什么是代理,什么是装饰器模式),但是我认为装饰器模式的本质是不改变原有接口的功能并增加新的功能,而

代理模式,具有装饰器模式的能力,并且有权利限制是否能够修改(改变)原有接口的功能 ...  所以我认为代理模式(它本质上是装饰器模式的超集) ...
  
 适配器模式,本质上将一个完全不同的实现(但是具有执行其他功能所需的能力时),可以进行适配来实现功能的快速拼接,而不需要如实实现一个满足于现有接口能力的对象..

## 外观模式详情

我认为 外观模式是组装各种子系统能力(以及协调资源)的一种代理形式,和抽象工厂模式不同的是,不需要每一个实现者都实现抽象工厂所定义的方法和功能..
因为抽象工厂面向的需求是根据特定要求产生满足要求的对象,而外观模式是进行各种子系统功能协调,它统一代理面向子系统外部的对外暴露,客户端只知道外观,
而无需知道所有内部子系统,所以外观模式和抽象工厂很像,同时也满足于SPI(服务发现模式),因为都是向外暴露一个统一的形式,而内部实现取决于具体行为 ..

例如,特定实现,或者优先级注册,或者策略处理.. 

## 总结
   相比于抽象工厂模式来说,它更灵活,满足于对修改关闭,对扩展开放,例如它可以在当前已有接口上添加新功能,而只需要在外观下去协调子系统工作即可,而子系统
   之间完全可以相互交流,因为只是外观和客户端对接,内部子系统交流根本不受限制 ..
   
   并且,可以根据需求,实现特定的抽象接口来定义新的行为,并通过其他设计模式,将这一系列接口关联起来实现特定的系统行为 ..

   其次,外观模式,本质上和策略模式也很像,当你拥有多种功能的时候,策略处理功能,或者联合起来,让客户端随意传入,来使用特定的功能处理,那么本质上内部依旧是策略在处理,
   只是通过聚合的方式让它们以另一种方式实施行为,同时无法感知外观,而且能够完成外观交代的事情 ...


## 其他资源

- https://github.com/dunwu/dunwu.github.io/blob/main/docs/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.md 

   对比了各种策略模式和外观模式的异同,以及外观模式在什么场景下可用...