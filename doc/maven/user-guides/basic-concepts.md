# 基本概念
## 1. 命名约定
groupId,artificatId,version的命名约定
- groupId

    groupid 独一无二的标识在项目集中的项目,一个groupId 应该总是遵循 `[java的包名规则](https://docs.oracle.com/javase/specs/jls/se6/html/packages.html#7.7)` .
    一般是基于域名控制反转.. 例如 `org.apache.maven`,`org.apache.commons` 
    
    maven 并不强制这个规则,许多遗留的项目并没有遵循这个规则并且相反使用单个词作为groupId,然而现在很难去获得一个赞许的单个词的groupId(包含在maven中央仓库中的这一类groupId) ..

    你能够创建你想要的许多子分组,一个好的方式去确定groupId的粒度是 使用项目结构.. 那就是如果当前项目是一个多模块项目,它应该能够追加一个新的标识符到父亲的groupId,例如:
    
    `org.apache.maven`,`org.apache.maven.plugins` ,`org.apache.maven.reporting`  ..
- artifactId

    它标识jar的名称,如果你创建了它,那么你无论怎样都可以选择一个具有小写字符的名称(且不具备奇怪的符号),如果是第三方jar,你能够根据它jar的分发名称作为工件名称 ..
    例如,`maven`,`commons-math` ...
- version
    版本,如果你发布了它,那么你能够选择任何通常的版本(具有数字和点的版本 - 例如[1.0,1.1,1.0.1]),不要使用时间(日期) - 因为它们通常与SNAPSHOT(nightly)构建关联 ..
    如果它是一个第三方工件,那么你能够使用任何想要的版本号,就算它看起来很奇怪 ..  例如 `2.0`,`2.0.1` ,`1.3.1` ...

## 2. 介绍构建生命周期

### 2.1 构建生命周期基础知识
maven 是基于构建生命周期的核心概念展开的.. 也就是构建 以及 发布一个特定的工件(项目)的过程是非常清楚的 ..

为了让用户构建项目,这意味着仅仅只要学习少量的命令去构建任何maven项目... 并且POM 描述符文件确保能够获得它们渴望的结果 ..

这里有三种内置的构建生命周期: default,clean and site.  `default`生命周期处理项目的部署.. `clean` 生命周期处理项目清理,然而`site` 生命周期
处理你的项目站点的创建  ..

### 2.2 一个构建生命周期是由多个阶段组成
这些构建生命周期 都具有一组不同的构建阶段 ... 此时一个构建阶段 代表着在生命周期中的一个阶段 ..

例如,default 生命周期由以下的阶段组成(对于生命周期的完整列表,参考 [Lifecycle Reference](https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference) )
- validate 验证项目是正确的并且所有必要的信息都可用
- compile 编译项目的源代码
- test 测试编译的源代码   - 使用合适的单元测试框架 .. 这个测试代码并不会打包和部署 ..
- package 将编译的代码并打包它在可发布的形式中,例如 jar
- verify 运行任何在集成测试的结果去确保质量标准 ..
- install 安装打包到本地仓库中,为了作为依赖在其他项目中使用 ..
- deploy 在构建环境中完成, 复制最终的打包文件到远程仓库中 - 为了与其他开发者和项目共享 ..

这些生命周期阶段(加上其他没有在这里展示的生命周期阶段) 将会依次执行 - 去完成的`default` 生命周期 .. 给定上面的生命周期阶段 ... 
这意味着 - 当default 生命周期使用的时候 ..
maven 首先会验证这个项目,然后将尝试编译这个资源,运行测试,打包二进制(jar),根据打包去运行集成测试 .. 验证集成测试结果并安装验证完成的包到本地的仓库 ..
然后部署安装的包到 远程仓库 ...

## 3. 常见命令行调用
你应该选择匹配阶段去匹配你的输出(或者结果),如果你想要获得一个jar,那么你应该运行package,如果你想要运行单元测试,那么运行test ..

如果你不确定你想要什么，那么推荐的调用阶段是
```shell
mvn verify
```
这个命令有序的执行每一个默认的生命周期(validate,compile,package,等等),再执行`verify` 之前,你仅仅需要调用最后一个需要执行的构建阶段,
这种情况下,就是`verify`, 在大多数情况下效果等价于`package` ,然而,在集成测试的情况下,这些也同样会被执行 ..  也就是说`verify` 阶段所经历的
生命周期更长, 并且在`verify` 阶段之间某些额外的检查能够完成 ...

例如你的代码是根据预定义的checkstyle 规则编写的 ..(checkstyle 插件是一种代码风格)

在一个构建环境中,使用以下的调用去清理构建并且部署工件到共享的仓库 ..
```shell
mvn clean deploy
```

这相同的命令也能够使用在多模块场景中(例如,一个具有一个或者多个子项目的项目). maven 将会遍历每一个子项目并执行clean ..
然后执行`deploy`(包括所有之前的构建步骤..)


## 4. 一个构建阶段有多个插件的goals(目标)组成

然而,即使一个构建阶段负责构建生命周期的特定步骤,总体上它们履行这些职责有所不同 ...
这是通过声明插件目标绑定到这些构建阶段中完成的 ...

一个插件goal 代表了一个特定的任务(比构建阶段细腻) - 这能够去贡献构建并管理项目 ... 它也许可以绑定到零或者多个构建阶段 ..
一个goal 没有绑定到任何构建阶段 能够通过直接执行 / 调用, 执行顺序依赖于这些goals 以及 构建阶段被调用的顺序 ...

例如,考虑下面的命令,这个`clean` 以及 `package` 参数是构建阶段, 然而`dependency:copy-dependencies` 是一个插件的目标 ..(goal)
```shell
mvn clean dependency:copy-dependencies package
```
如果这被执行,那么`clean` 阶段将首先被执行(意味着它将运行所有 clean 声明周期的前置阶段, 加上`clean` 阶段自身),
在最终执行`package` 阶段之前(以及所有它前面的默认生命周期的构建阶段) - 然后是`dependency:copy-dependencies` 目标 执行..

此外,如果一个目标绑定到一个或者多个构建阶段,那么在这些阶段中此目标都会被调用 .
因此,一个构建阶段能够绑定多个目标, 如果一个构建阶段没有目标绑定到它,那么构建阶段将不会执行,因为真正的任务就是目标执行, 但是如果存在多个
目标绑定到它,那么它将执行所有的目标 ..

> 注意:
> 从maven 2.0.5开始及其以上, 多个目标绑定到一个阶段 所被执行的顺序和在pom中声明的顺序相同. 然而相同插件的多个实例是不支持的 ...
> 在Maven 2.0.11及以上版本中，同一插件的多个实例会被分组，以便一起执行并排序。


## 5. 某些阶段通常不从命令行调用
具有连字符号的单词的阶段(pre-*,post-*,process-*) 通常不会直接从命令行调用 ... 这些阶段排序此构建, 生产的中间结果将在构建之外是不可用的(产生了一些在构建之外无用的中间结果).. 
在执行`integration-test` 的情况下,这个环境可能会被留在悬空的状态中。

代码覆盖工具 例如jacoco 以及执行容器插件(例如 tomcat,cargo,以及 docker 绑定目标到 `pre-integration-test` 阶段去准备集成测试容器环境)
这些插件也绑定目标到 `post-integration-test` 阶段去收集覆盖统计或者 撤销集成测试容器 ..

安全失败 以及覆盖插件绑定目标到`integration-test` 以及 `verify` 阶段.  纯粹的结果是在`verify` 阶段之后测试以及覆盖报告可用 ..
如果`integration-test` 从命令行调用,将没有报告生成 ... 更坏的结果是 集成测试容器环境将处于悬空的状态 ... 
tomcat webserver 以及 docker 实例 如果正在运行, 以及 maven 也许甚至不会中断自己 ...

也就是,某些阶段需要在maven 构建过程中执行, 