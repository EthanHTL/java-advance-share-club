# spring aop apis
# 6.1 在 spring中的切入点api ..
## 6.1.1 概念
spring的切入点模型能够启用切入点去重用各种advice 类型,并且在相同的切入点上关联不同的advice .. \
org.springframework.aop.Pointcut 接口是核心接口,主要为了绑定advice到不同的类和方法 ..
同样,切入点本身支持联合或者交集操作符 ...(可以进行组合) .. \
这个接口中的ClassFilter 无非就是限制切入点可以应用到那些目标类 ,方法匹配器MethodMatcher接口通常更加重要,
那么这个匹配本身通过isRuntime() 判断是否为一种静态的处理方式,如果为静态,那么匹配结果可以获得缓存,使得获得较高的性能,因为假设每一次执行时都需要
评估匹配条件,那么性能损耗肯定必然更大 ...(例如动态方法匹配器,也就是根据运算表达式来判断是否需要执行advice ..),根据isRuntime()的返回结果,
matches方法的不同重载将会得到不同的调用 ...(例如静态的处理方式一般仅仅关心类和方法,而不关心方法参数,因为动态的处理肯定需要根据参数进行表达式处理 ..)

## 6.1.2 切入点的操作
org.springframework.aop.support.Pointcuts 有支持逻辑关联切入点的一些工具方法,ComposablePointcut 主要是底层的核心设计(来呈现这些操作关系) ...
## 6.1.3 AspectJ 表达式切入点
AspectJExpressionPointcut是 AspectJ 框架提供的,用来解析AspectJ 切入点表达式字符串 ..

## 6.1.4 方便的切入点实现
### 静态切入点
也就是静态处理方式,能够仅仅考虑一次匹配条件,后续执行能够获得性能提升(因为不需要匹配条件执行) ..
### 正则表达式切入点
JdkRegexpMethodPointcut , 支持 JDK 的正则表达式 ...,通过这个类,你能够提供一个表达式字符串列表,它们的关系是或者,只要有一个评估成功即可 \
### 属性驱动的切入点
一般来说就是注解 ...
### 动态切入点
官方解释了一个示例就是(control flow)切入点,每一次方法执行都需要评估切入点,性能消耗非常大 ..
### Control Flow 切入点
spring 的这个控制流切入点概念上类似于AspectJ cflow 切入点,这可能使用场景非常少,当前没有一种方式去指定一个切入点运行在由另一个切入点匹配的连接点下面（这句话可能有问题） ..
那么此切入点如何工作,它是通过匹配当前的调用栈进行处理 (也就是根据当前调用栈中是否匹配对应的类和方法),显然这是一种动态的切入点,性能消耗很大 .. \
rg.springframework.aop.support.ControlFlowPointcut 是对应物 ,然后在java 1.4中,消耗是其他动态切入点的4倍 ..

### 切入点的超类
spring 提供了很多切入点实现,你可以根据你自己的业务场景实现不同的切入点 ,例如静态切入点很有用,你可以继承StaticMethodMatcherPointcut 子类 ..
### 自定义切入点
由于Spring aop中的切入点是java类而不是 语言特性(AspectJ),你能够声明自定义的切入点(无论是动态还是静态) .. 但是非常建议使用AspectJ 切入点表达式语言 ..
> Spring 的更高版本可能会支持 JAC 提供的“语义切入点”——例如，“所有改变目标对象中实例变量的方法”。

